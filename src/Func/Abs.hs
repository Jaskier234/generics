-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Func.

module Func.Abs where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type Program = Program' BNFC'Position
data Program' a = Prog a [Declaration' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Declaration = Declaration' BNFC'Position
data Declaration' a
    = DeclFun a (FuncDecl' a) | DeclType a (TypeDecl' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FuncDecl = FuncDecl' BNFC'Position
data FuncDecl' a = FDecl a (Type' a) Ident [Arg' a] (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Arg = Arg' BNFC'Position
data Arg' a
    = AIdent a Ident
    | APattern a UIdent [Arg' a]
    | AEmpList a
    | AList a (Arg' a) (Arg' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Type = Type' BNFC'Position
data Type' a
    = TInt a
    | TBool a
    | TVar a Ident
    | TList a (Type' a)
    | TData a UIdent [Type' a]
    | TFunc a (Type' a) (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypeDecl = TypeDecl' BNFC'Position
data TypeDecl' a = TDecl a UIdent [Ident] [Constructor' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Constructor = Constructor' BNFC'Position
data Constructor' a = TCons a UIdent [Type' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Exp = Exp' BNFC'Position
data Exp' a
    = ENum a Integer
    | ETrue a
    | EFalse a
    | EVar a Ident
    | ECons a UIdent
    | ECall a (Exp' a) (Exp' a)
    | ENot a (Exp' a)
    | ENeg a (Exp' a)
    | EEq a (Exp' a) (Exp' a)
    | ELq a (Exp' a) (Exp' a)
    | EGq a (Exp' a) (Exp' a)
    | ELe a (Exp' a) (Exp' a)
    | EGe a (Exp' a) (Exp' a)
    | ENq a (Exp' a) (Exp' a)
    | EMul a (Exp' a) (Exp' a)
    | EDiv a (Exp' a) (Exp' a)
    | EAdd a (Exp' a) (Exp' a)
    | ESub a (Exp' a) (Exp' a)
    | EList a (List' a)
    | ECase a (Exp' a) [Case' a]
    | ELambda a (Type' a) [Arg' a] (Exp' a)
    | EIf a (Exp' a) (Exp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Case = Case' BNFC'Position
data Case' a = Case a (Arg' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type List = List' BNFC'Position
data List' a
    = LEmpty a | LCon a (Exp' a) (Exp' a) | LSugar a [Exp' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype UIdent = UIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Program where
  hasPosition = \case
    Prog p _ -> p

instance HasPosition Declaration where
  hasPosition = \case
    DeclFun p _ -> p
    DeclType p _ -> p

instance HasPosition FuncDecl where
  hasPosition = \case
    FDecl p _ _ _ _ -> p

instance HasPosition Arg where
  hasPosition = \case
    AIdent p _ -> p
    APattern p _ _ -> p
    AEmpList p -> p
    AList p _ _ -> p

instance HasPosition Type where
  hasPosition = \case
    TInt p -> p
    TBool p -> p
    TVar p _ -> p
    TList p _ -> p
    TData p _ _ -> p
    TFunc p _ _ -> p

instance HasPosition TypeDecl where
  hasPosition = \case
    TDecl p _ _ _ -> p

instance HasPosition Constructor where
  hasPosition = \case
    TCons p _ _ -> p

instance HasPosition Exp where
  hasPosition = \case
    ENum p _ -> p
    ETrue p -> p
    EFalse p -> p
    EVar p _ -> p
    ECons p _ -> p
    ECall p _ _ -> p
    ENot p _ -> p
    ENeg p _ -> p
    EEq p _ _ -> p
    ELq p _ _ -> p
    EGq p _ _ -> p
    ELe p _ _ -> p
    EGe p _ _ -> p
    ENq p _ _ -> p
    EMul p _ _ -> p
    EDiv p _ _ -> p
    EAdd p _ _ -> p
    ESub p _ _ -> p
    EList p _ -> p
    ECase p _ _ -> p
    ELambda p _ _ _ -> p
    EIf p _ _ _ -> p

instance HasPosition Case where
  hasPosition = \case
    Case p _ _ -> p

instance HasPosition List where
  hasPosition = \case
    LEmpty p -> p
    LCon p _ _ -> p
    LSugar p _ -> p

