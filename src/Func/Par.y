-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Func.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Func.Abs
import Func.Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '->' { PT _ (TS _ 9) }
  '/' { PT _ (TS _ 10) }
  ':' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'False' { PT _ (TS _ 20) }
  'Int' { PT _ (TS _ 21) }
  'True' { PT _ (TS _ 22) }
  '[' { PT _ (TS _ 23) }
  '[]' { PT _ (TS _ 24) }
  '\\' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  'case' { PT _ (TS _ 27) }
  'data' { PT _ (TS _ 28) }
  'def' { PT _ (TS _ 29) }
  'else' { PT _ (TS _ 30) }
  'endif' { PT _ (TS _ 31) }
  'if' { PT _ (TS _ 32) }
  'of' { PT _ (TS _ 33) }
  'then' { PT _ (TS _ 34) }
  'type' { PT _ (TS _ 35) }
  '{' { PT _ (TS _ 36) }
  '|' { PT _ (TS _ 37) }
  '}' { PT _ (TS _ 38) }
  L_Ident  { PT _ (TV _) }
  L_integ  { PT _ (TI _) }
  L_UIdent { PT _ (T_UIdent _) }

%%

Ident :: { (Func.Abs.BNFC'Position, Func.Abs.Ident) }
Ident  : L_Ident { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.Ident (tokenText $1)) }

Integer :: { (Func.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

UIdent :: { (Func.Abs.BNFC'Position, Func.Abs.UIdent) }
UIdent  : L_UIdent { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.UIdent (tokenText $1)) }

Program :: { (Func.Abs.BNFC'Position, Func.Abs.Program) }
Program : ListDeclaration { (fst $1, Func.Abs.Prog (fst $1) (snd $1)) }

Declaration :: { (Func.Abs.BNFC'Position, Func.Abs.Declaration) }
Declaration : FuncDecl { (fst $1, Func.Abs.DeclFun (fst $1) (snd $1)) }
            | TypeDecl { (fst $1, Func.Abs.DeclType (fst $1) (snd $1)) }

ListDeclaration :: { (Func.Abs.BNFC'Position, [Func.Abs.Declaration]) }
ListDeclaration : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
                | Declaration ListDeclaration { (fst $1, (:) (snd $1) (snd $2)) }

FuncDecl :: { (Func.Abs.BNFC'Position, Func.Abs.FuncDecl) }
FuncDecl : 'type' Type 'def' Ident ListArg1 '=' Exp { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.FDecl (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $5) (snd $7)) }

Arg1 :: { (Func.Abs.BNFC'Position, Func.Abs.Arg) }
Arg1 : Ident { (fst $1, Func.Abs.AIdent (fst $1) (snd $1)) }
     | '(' Arg ')' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Arg :: { (Func.Abs.BNFC'Position, Func.Abs.Arg) }
Arg : UIdent ListArg1 { (fst $1, Func.Abs.APattern (fst $1) (snd $1) (snd $2)) }
    | '[]' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.AEmpList (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
    | Arg1 ':' Arg1 { (fst $1, Func.Abs.AList (fst $1) (snd $1) (snd $3)) }
    | Arg1 { (fst $1, (snd $1)) }

ListArg1 :: { (Func.Abs.BNFC'Position, [Func.Abs.Arg]) }
ListArg1 : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
         | Arg1 ListArg1 { (fst $1, (:) (snd $1) (snd $2)) }

Type2 :: { (Func.Abs.BNFC'Position, Func.Abs.Type) }
Type2 : 'Int' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.TInt (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
      | 'Bool' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.TBool (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
      | Ident { (fst $1, Func.Abs.TVar (fst $1) (snd $1)) }
      | '[' Type ']' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.TList (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
      | '(' Type ')' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type1 :: { (Func.Abs.BNFC'Position, Func.Abs.Type) }
Type1 : UIdent ListType2 { (fst $1, Func.Abs.TData (fst $1) (snd $1) (snd $2)) }
      | Type2 { (fst $1, (snd $1)) }

Type :: { (Func.Abs.BNFC'Position, Func.Abs.Type) }
Type : Type1 '->' Type { (fst $1, Func.Abs.TFunc (fst $1) (snd $1) (snd $3)) }
     | Type1 { (fst $1, (snd $1)) }

ListType2 :: { (Func.Abs.BNFC'Position, [Func.Abs.Type]) }
ListType2 : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
          | Type2 ListType2 { (fst $1, (:) (snd $1) (snd $2)) }

TypeDecl :: { (Func.Abs.BNFC'Position, Func.Abs.TypeDecl) }
TypeDecl : 'data' UIdent ListIdent '=' ListConstructor { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.TDecl (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }

Constructor :: { (Func.Abs.BNFC'Position, Func.Abs.Constructor) }
Constructor : UIdent ListType2 { (fst $1, Func.Abs.TCons (fst $1) (snd $1) (snd $2)) }

ListConstructor :: { (Func.Abs.BNFC'Position, [Func.Abs.Constructor]) }
ListConstructor : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
                | Constructor { (fst $1, (:[]) (snd $1)) }
                | Constructor '|' ListConstructor { (fst $1, (:) (snd $1) (snd $3)) }

ListIdent :: { (Func.Abs.BNFC'Position, [Func.Abs.Ident]) }
ListIdent : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
          | Ident ListIdent { (fst $1, (:) (snd $1) (snd $2)) }

Exp10 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp10 : Integer { (fst $1, Func.Abs.ENum (fst $1) (snd $1)) }
      | 'True' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.ETrue (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
      | 'False' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.EFalse (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
      | Ident { (fst $1, Func.Abs.EVar (fst $1) (snd $1)) }
      | UIdent { (fst $1, Func.Abs.ECons (fst $1) (snd $1)) }
      | '(' Exp ')' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp8 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp8 : Exp8 Exp10 { (fst $1, Func.Abs.ECall (fst $1) (snd $1) (snd $2)) }
     | Exp9 { (fst $1, (snd $1)) }

Exp7 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp7 : '!' Exp8 { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.ENot (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
     | Exp8 { (fst $1, (snd $1)) }

Exp6 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp6 : '-' Exp7 { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.ENeg (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
     | Exp7 { (fst $1, (snd $1)) }

Exp5 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp5 : Exp6 '==' Exp6 { (fst $1, Func.Abs.EEq (fst $1) (snd $1) (snd $3)) }
     | Exp6 '<' Exp6 { (fst $1, Func.Abs.ELq (fst $1) (snd $1) (snd $3)) }
     | Exp6 '>' Exp6 { (fst $1, Func.Abs.EGq (fst $1) (snd $1) (snd $3)) }
     | Exp6 '<=' Exp6 { (fst $1, Func.Abs.ELe (fst $1) (snd $1) (snd $3)) }
     | Exp6 '>=' Exp6 { (fst $1, Func.Abs.EGe (fst $1) (snd $1) (snd $3)) }
     | Exp6 '!=' Exp6 { (fst $1, Func.Abs.ENq (fst $1) (snd $1) (snd $3)) }
     | Exp6 { (fst $1, (snd $1)) }

Exp4 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp4 : Exp4 '*' Exp5 { (fst $1, Func.Abs.EMul (fst $1) (snd $1) (snd $3)) }
     | Exp4 '/' Exp5 { (fst $1, Func.Abs.EDiv (fst $1) (snd $1) (snd $3)) }
     | Exp5 { (fst $1, (snd $1)) }

Exp3 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp3 : Exp3 '+' Exp4 { (fst $1, Func.Abs.EAdd (fst $1) (snd $1) (snd $3)) }
     | Exp3 '-' Exp4 { (fst $1, Func.Abs.ESub (fst $1) (snd $1) (snd $3)) }
     | Exp4 { (fst $1, (snd $1)) }

Exp2 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp2 : List { (fst $1, Func.Abs.EList (fst $1) (snd $1)) }
     | Exp3 { (fst $1, (snd $1)) }

Exp1 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp1 : 'case' Exp2 'of' '{' ListCase '}' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.ECase (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
     | 'type' Type '\\' ListArg1 '->' Exp2 { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.ELambda (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
     | Exp2 { (fst $1, (snd $1)) }

Exp :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp : 'if' Exp 'then' Exp 'else' Exp 'endif' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.EIf (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
    | Exp1 { (fst $1, (snd $1)) }

Exp9 :: { (Func.Abs.BNFC'Position, Func.Abs.Exp) }
Exp9 : Exp10 { (fst $1, (snd $1)) }

Case :: { (Func.Abs.BNFC'Position, Func.Abs.Case) }
Case : Arg '->' Exp { (fst $1, Func.Abs.Case (fst $1) (snd $1) (snd $3)) }

ListCase :: { (Func.Abs.BNFC'Position, [Func.Abs.Case]) }
ListCase : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
         | Case { (fst $1, (:[]) (snd $1)) }
         | Case ';' ListCase { (fst $1, (:) (snd $1) (snd $3)) }

List :: { (Func.Abs.BNFC'Position, Func.Abs.List) }
List : '[]' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.LEmpty (uncurry Func.Abs.BNFC'Position (tokenLineCol $1))) }
     | Exp6 ':' Exp6 { (fst $1, Func.Abs.LCon (fst $1) (snd $1) (snd $3)) }
     | '[' ListExp ']' { (uncurry Func.Abs.BNFC'Position (tokenLineCol $1), Func.Abs.LSugar (uncurry Func.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListExp :: { (Func.Abs.BNFC'Position, [Func.Abs.Exp]) }
ListExp : {- empty -} { (Func.Abs.BNFC'NoPosition, []) }
        | Exp { (fst $1, (:[]) (snd $1)) }
        | Exp ',' ListExp { (fst $1, (:) (snd $1) (snd $3)) }
{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Func.Abs.Program
pProgram = fmap snd . pProgram_internal
}

