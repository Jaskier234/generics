-- Haskell module generated by the BNF converter

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Func.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Func.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Func.Abs.Ident -> Result
transIdent x = case x of
  Func.Abs.Ident string -> failure x

transUIdent :: Func.Abs.UIdent -> Result
transUIdent x = case x of
  Func.Abs.UIdent string -> failure x

transProgram :: Show a => Func.Abs.Program' a -> Result
transProgram x = case x of
  Func.Abs.Prog _ declarations -> failure x

transDeclaration :: Show a => Func.Abs.Declaration' a -> Result
transDeclaration x = case x of
  Func.Abs.DeclFun _ funcdecl -> failure x
  Func.Abs.DeclType _ typedecl -> failure x

transFuncDecl :: Show a => Func.Abs.FuncDecl' a -> Result
transFuncDecl x = case x of
  Func.Abs.FDecl _ type_ ident args exp -> failure x

transArg :: Show a => Func.Abs.Arg' a -> Result
transArg x = case x of
  Func.Abs.AIdent _ ident -> failure x
  Func.Abs.APattern _ uident args -> failure x
  Func.Abs.AEmpList _ -> failure x
  Func.Abs.AList _ arg1 arg2 -> failure x

transType :: Show a => Func.Abs.Type' a -> Result
transType x = case x of
  Func.Abs.TInt _ -> failure x
  Func.Abs.TBool _ -> failure x
  Func.Abs.TVar _ ident -> failure x
  Func.Abs.TList _ type_ -> failure x
  Func.Abs.TData _ uident types -> failure x
  Func.Abs.TFunc _ type_1 type_2 -> failure x

transTypeDecl :: Show a => Func.Abs.TypeDecl' a -> Result
transTypeDecl x = case x of
  Func.Abs.TDecl _ uident idents constructors -> failure x

transConstructor :: Show a => Func.Abs.Constructor' a -> Result
transConstructor x = case x of
  Func.Abs.TCons _ uident types -> failure x

transExp :: Show a => Func.Abs.Exp' a -> Result
transExp x = case x of
  Func.Abs.ENum _ integer -> failure x
  Func.Abs.ETrue _ -> failure x
  Func.Abs.EFalse _ -> failure x
  Func.Abs.EVar _ ident -> failure x
  Func.Abs.ECons _ uident -> failure x
  Func.Abs.ECall _ exp1 exp2 -> failure x
  Func.Abs.ENot _ exp -> failure x
  Func.Abs.ENeg _ exp -> failure x
  Func.Abs.EEq _ exp1 exp2 -> failure x
  Func.Abs.ELq _ exp1 exp2 -> failure x
  Func.Abs.EGq _ exp1 exp2 -> failure x
  Func.Abs.ELe _ exp1 exp2 -> failure x
  Func.Abs.EGe _ exp1 exp2 -> failure x
  Func.Abs.ENq _ exp1 exp2 -> failure x
  Func.Abs.EMul _ exp1 exp2 -> failure x
  Func.Abs.EDiv _ exp1 exp2 -> failure x
  Func.Abs.EAdd _ exp1 exp2 -> failure x
  Func.Abs.ESub _ exp1 exp2 -> failure x
  Func.Abs.EList _ list -> failure x
  Func.Abs.ECase _ exp cases -> failure x
  Func.Abs.ELambda _ type_ args exp -> failure x
  Func.Abs.EIf _ exp1 exp2 exp3 -> failure x

transCase :: Show a => Func.Abs.Case' a -> Result
transCase x = case x of
  Func.Abs.Case _ arg exp -> failure x

transList :: Show a => Func.Abs.List' a -> Result
transList x = case x of
  Func.Abs.LEmpty _ -> failure x
  Func.Abs.LCon _ exp1 exp2 -> failure x
  Func.Abs.LSugar _ exps -> failure x
